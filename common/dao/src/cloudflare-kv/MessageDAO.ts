import { MessageDAO, MessageMetadataResponse } from '../MessageDAO'
import Mailbox from '../models/Mailbox.model';
import Message from '../models/Message.model';
import MimePart from '../models/MimePart.model';
import PostalMime from 'postal-mime' // AGPL :(
import { Ulid } from 'id128'
import { Env } from '../DAOFactory';

export class CloudflareKVMessageDAO implements MessageDAO {

    private env: Env;

    constructor(env: Env) {
        this.env = env;
    }

    generateId(): string {
        return Ulid.generate().toCanonical();
    }

    async getParsed(mailbox: Mailbox, messageId: string): Promise<Message> {
        const messageKey = `${mailbox.id}:${messageId}`;
        const messageMetadata = await this.env.MessageMetadata.get(messageKey, { cacheTtl: 60 });
        return new Message(messageId, JSON.parse(messageMetadata || '{}'));
    }

    async getRaw(mailbox: Mailbox, messageId: string): Promise<ArrayBuffer> {
        const messageKey = `${mailbox.id}:${messageId}`;
        const blob = await this.env.MessageBlob.get(messageKey);
        return blob!.arrayBuffer();
    }

    async put(mailbox: Mailbox, messageId: string, partialMessage: Message, raw: Promise<string | ArrayBuffer | Blob>): Promise<void> {
        const messageKey = `${mailbox.id}:${messageId}`;
        const rawEmail = await raw;

        // Store message blob
        await this.env.MessageBlob.put(messageKey, rawEmail);

        const parsedEmail = await new PostalMime().parse(rawEmail);
        const message = new Message(messageId, parsedEmail);
        message.labels = partialMessage.labels;
        message.markers = partialMessage.markers;

        if (rawEmail instanceof Blob) {
            message.size = rawEmail.size;
        } else if (rawEmail instanceof ArrayBuffer) {
            message.size = rawEmail.byteLength;
        } else if (typeof rawEmail === "string") {
            message.size = rawEmail.length;
        }

        if (parsedEmail.attachments.length > 0) {
            // TODO: MIME part ID hiearchy should be generated by the MIME parser. 
            //       Unfortunately, PostalMime does not support this yet.
            var partId = 1;
            const parts = new Map<string, MimePart>();

            parsedEmail.attachments.forEach(attachment => {
                const part = new MimePart(partId.toString(), attachment);
                parts.set(partId.toString(), part);
                partId++;
            });

            message.parts = parts;
        }

        // Add message metadata to mailbox
        await this.env.MessageMetadata.put(messageKey, message.asJSON());

        // Add message ID to mailbox label index
        for await (const label of message.labels) {
            await this.env.IndexLabels.put(`${mailbox.id}:${label}:${messageId}`, "");
        }
    }

    async getMessageIds(mailbox: Mailbox, labelId: number, offset: string, limit: number, reverse: boolean): Promise<Array<string>> {
        throw new Error('Method not implemented.');
    }

    async getMessagesWithMetadata(mailbox: Mailbox, labelId: number, offset: string, limit: number, reverse: boolean, includeBody: boolean): Promise<MessageMetadataResponse> {
        var messages = Array<Message>();

        const messageList = await this.env.MessageMetadata.list({ prefix: mailbox.id, limit: limit, cursor: offset })

        for await (const key of messageList.keys) {
            const messageId = key.name.split(":")[1];
            const messageJSON = await this.env.MessageMetadata.get(key.name, { cacheTtl: 60 });
            var message = new Message(messageId, JSON.parse(messageJSON || '{}'));
            messages.push(message);
        }

        const response: MessageMetadataResponse = {
            messages: messages,
            pagination: {
                next: messageList.list_complete === false ? messageList.cursor : null,
            }
        }

        return response;
    }

    async delete(mailbox: Mailbox, messageId: string): Promise<void> {
        const messageKey = `${mailbox.id}:${messageId}`
        const messageMetadata = await this.env.MessageMetadata.get(messageKey, { cacheTtl: 60 });
        const message = new Message(messageId, JSON.parse(messageMetadata || '{}'));

        // Delete message blob
        await this.env.MessageBlob.delete(messageKey);

        // Delete message metadata from mailbox
        await this.env.MessageMetadata.delete(messageKey)

        // Delete message ID from labels index
        for await (const label of message.labels) {
            await this.env.IndexLabels.delete(`${mailbox.id}:${label}:${messageId}`)
        }
    }
}
